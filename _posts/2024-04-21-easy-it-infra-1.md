---
layout: post
title: 초등학생도 이해하는 IT 인프라 구조 1 - IT 인프라의 기본 구조
subtitle: IT 인프라 기본구조, 데이터센터와 서버, 3계층형 시스템
author: honghyeong
categories: system
tags: [system]
sidebar: []
---

## 목차

- [초등학생도 이해하는 IT 인프라 (index)](https://honghyeong.github.io/system/2024/03/31/easy-it-infra-index.html)

## 1. IT 인프라의 기본 구조

IT 인프라는 **더욱 안정적인 서비스 운영과 비용효율적인 설계**를 위해서 계속해서 발전해왔습니다. IT 인프라를 구성하기 위해서 서버, 스토리지, 네트워크 장비, 데이터센터, 인건비 등 많은 비용이 필요하기 때문에, 필연적으로 비용적인 한계를 맞닥뜨릴 수 밖에 없었고, 어떻게하면 비용효율적으로 시스템을 확장하고, 운영할 수 있는지, 어떻게하면 안정성을 개선할 수 있을지에 대한 많은 고민이 있었다고 생각해볼 수 있습니다. **이제부터 IT 인프라 구조는 어떻게 발전했으며, 기존의 구조에는 어떤 문제가 있었고, 그 문제를 해결하려고 어떤 새로운 아키텍처(기술)을 설계했는지, 그 아키텍처에는 어떤 Trade-Off와 장단점이 있는지 집중하면서 알아보겠습니다.**

### 1-1. 집약형 아키텍처와 분산형 아키텍처

과거에는 대다수의 기업들이 “메인프레임”이라는 거대한 서버를 활용한 **“집약형 아키텍처”**로 많은 서비스를 운영했습니다. 메인프레임은 내부적으로 다양한 컴포넌트(CPU, 메모리, 디스크, … 등)를 이중화하여 안정적인 서비스 제공이 가능했지만, 비용이 턱없이 비싸기 때문에 서비스를 확장하게되면 비용적인 문제가 있을 수 밖에 없었습니다.

반도체 기술의 발전에 따라서 서버 내 컴포넌트들은 작은 크기에서도 좋은 성능을 낼 수 있게 되었고, 아키텍처 설계를 통해서 메인프레임 만큼의 안정성도 갖출 수 있게 되면서, 현대에는 주로 다수의 작은 서버들을 이용하여 서비스를 제공하는 **“분산형 아키텍처”**로 IT 인프라를 제공하고 있습니다.

|      | 집약형 아키텍처                                                                                                            | 분산형 아키텍처                                                                             |
| ---- | -------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| 특징 | 하나의 메인프레임으로 시스템을 구축하고, 동시에 여러 업무를 처리하는 아키텍처                                              | 여러 대의 작은 서버로 하나의 시스템을 구축하는 아키텍처                                     |
| 장점 | 하나의 메인프레임만 관리하면되므로 운영 난이도가 낮다, 메인프레임 내 대부분의 컴포넌트가 이중화되어있으므로 안정성이 높다. | 메인프레임에 비해 서버의 가격이 저렴하므로 비용효율적이고, 서비스를 새로 확장하기 쉽다.     |
| 단점 | 서버를 새로 도입할때의 비용이 높은 편이기때문에 비용효율성이 떨어진다.                                                     | 시스템 내 관리해야하는 서버의 수가 많아지므로, 시스템이 복잡해지고, 운영 난이도가 높아진다. |

<details>
<summary>검색해볼만한 키워드</summary>
<div markdown="1">
* 메인프레임

</div>
</details>

<br>
<br>

### 1-2. 수직 분산형 아키텍처와 수평 분산형 아키텍처

위의 **분산형 아키텍처**는 아키텍처 설계를 통해서 안정성을 보완한다고 했습니다. 분산형 아키텍처는 크게 두 가지 방법으로 시스템의 안정성을 보완합니다. 역할 별로 서버를 나누어 안정성을 개선하는 **수직 분산형 아키텍처**와, 같은 역할을 하는 서버를 여러 대 두어 안정성을 개선하는 **수평 분산형 아키텍처** 입니다

인형을 만드는 공장을 예로 들어보겠습니다.

인형을 완성하기 위해서 인형의 눈을 붙이고, 옷을 입히고, 포장하는 총 3단계의 작업이 필요하다고 합니다. **수직 분산형 아키텍처**는 한 사람이 모든 작업을 해야하는 것이 아니라 세 명의 사람이 각각의 작업을 분업한다고 볼 수 있습니다. 각자 하나의 작업만 반복하면 되기때문에 효율적이고, 복잡성이 줄어들어 안정적 입니다. 반면, **수평 분산형 아키텍처**는 인형의 눈을 붙이는 사람을 여럿 두는 것입니다. 작업을 나누어가지므로, 한 사람이 해야하는 작업이 줄어들고, 한 사람이 몸이 아파서 쉬더라도 다른 사람이 그 작업을 할 수 있으므로 인형을 만드는 공정에는 큰 영향이 없으므로, 안정적입니다.

특징과 장단점에 대해서 조금 더 자세히 알아보겠습니다.

|      | 수직 분산형 아키텍처                                                                        | 수평 분산형 아키텍처                                                                           |
| ---- | ------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| 특징 | 서버를 역할에 따라 계층을 나눠서 분산하는 아키텍처                                          | 같은 역할을 하는 서버를 여러대 두어 분산하는 아키텍처                                          |
| 장점 | 역할별로 서버를 나누어 부하를 분산할 수 있어 각 서버의 안정성을 개선할 수 있다.             | 같은 역할을 하는 서버가 여러대 있어 부하를 분산하고, 특정 서버에 문제가 생겨도 큰 문제가 없다. |
| 단점 | 시스템 내 관리해야하는 서버의 수가 많아지므로, 시스템이 복잡해지고, 운영 난이도가 높아진다. | 시스템 내 관리해야하는 서버의 수가 많아지므로, 시스템이 복잡해지고, 운영 난이도가 높아진다.    |

<br>

수평 분산형 아키텍처는 서버 뿐만아니라, 동일한 기능을 하는 시스템을 하나 더 두는 방식으로 수평 분산을 설계하기도 합니다. 유튜브를 예로 들어봅시다. 유튜브는 일본, 미국 각각의 국가별로 유튜브 시스템이 있을 것 입니다. 만약에 시스템간에 데이터 연동이 되지않는다면, 대한민국 사람들은 미국의 유튜브 시스템에서 업로드된 컨텐츠를 볼 수 없게 되는 것입니다. 하지만 미국의 유튜브 시스템에 장애가 생겨도, 한국의 유튜브는 문제없이 컨텐츠를 시청할 수 있습니다.

이렇게, 각 시스템이 데이터를 공유 할지에 따라서 아키텍처 종류를 한번 더 나눌 수 있습니다. 단순히 여러개의 독립적인 시스템을 수평으로 두는 **"단순 수평분산형 아키텍처"**가 있는 반면, **"공유 수평분산형 아키텍처"**처럼 시스템간의 데이터가 동기화되어야 한다면 데이터를 공유하기 위한 기술, 장애 전파를 막기위한 기술 등이 필요하여 관리와 운영이 더 어려워진다고 볼 수 있습니다.

|      | 단순 수평분산형 아키텍처                                                                                                                         | 공유 수평분산형 아키텍처                                                                                                                              |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| 특징 | 단순히 같은 기능을 하는 시스템을 여러 개 두어 수평 분산하는 아키텍처. 시스템간에는 데이터를 공유하지 않는다.                                     | 같은 기능을 하는 시스템을 여러 개 두고, 시스템간 데이터를 공유하는 아키텍처                                                                           |
| 장점 | 각 시스템은 완전히 독립적이므로, 한 시스템의 장애가 다른 시스템으로 전파되지않는다. 수평분산형 아키텍처와 동일하게 부하를 분산하므로 안정적이다. | 수평분산을 통해 안정적이고, 각 시스템간에 데이터가 공유되어, 다른 시스템의 데이터를 활용할 수 있다.                                                   |
| 단점 | 시스템 간의 데이터 공유가 어렵다. 하나의 시스템을 동일하게 구축해야하므로 많은 비용이 든다.                                                      | 공유 데이터에 대한 별도의 기술이 필요하고, 운영 및 관리가 더 복잡해진다. 데이터 연동 구간으로 인해서 확장성에 제약이 생기거나, 장애가 전파될 수 있다. |

<br>
<br>

### 1-3. 가용성 확보 아키텍처

IT 인프라를 구성하는 장비들은 하드웨어이므로 장비 노후화, 데이터센터 화재 등의 이유로 서버에 문제가 생겨 시스템에 장애가 발생할 수 있습니다. 그렇지만 많은 사람들의 삶에 막대한 영향을 끼치는 중요 서비스들은 예상치 못한 장애가 생기더라도, 안정적으로 운영할 수 있어야합니다. 장애가 생기더라도 서비스를 안정적으로 운영할 수 있는 것을 “가용성”이라고 합니다. 가용성을 확보하기 위한 아키텍처에는 **“이중화 아키텍처”, “재난 복구(DR) 아키텍처”**가 있습니다.

|      | 이중화 아키텍처                                                                                                                                                     | 재난 복구(DR) 아키텍처                                                                                                                                                                                                             |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 특징 | 서버를 여러 대 두어, active 서버에 장애가 생긴경우 신속하게 예비 서버(standby)를 가동하거나, 또다른 active 서버로 처리하는 아키텍처 (수평분산형과 원리가 동일하다.) | 데이터센터 화재, 지진, 해일 등 재난 상황을 고려하여 지리적으로 멀리 떨어진 곳에 임시로 운용가능한 시스템을 만들어두는 아키텍처                                                                                                     |
| 장점 | 작은 서버 장애에 대하여 대응하여 빠르게 서비스를 복구하고, 가용성을 확보할 수 있다.                                                                                 | 예상치못한 데이터센터 재난 상황에 대응하여 가용성을 확보할 수 있다.                                                                                                                                                                |
| 단점 | 서버를 여러 대 구입해야하므로 인프라 구축 비용이 N배가 된다.                                                                                                        | 서버는 물론이고, 별도의 데이터센터에 시스템을 구축하기 위해서 네트워크 장비, 스토리지 등을 구입해야하므로 막대한 비용이 들어간다. 언제라도 DR 환경으로 전환하기 위한 데이터 동기화, 변경관리 작업 등 운영 및 관리가 매우 복잡하다. |

<br>
<br>

## 2. 데이터센터와 서버의 구조

아키텍처를 이루는 서버들은, 우리가 집에서 사용하는 PC처럼 전원을 연결하고, 네트워크를 연결해야합니다. 기업에서 IT 인프라를 구축하는데 사용하는 물리서버들은 데이터센터라는 공간에 모여있고 랙(Rack)이라는 선반에 올라가게 됩니다. 서버가 입고되는 데이터센터는 여러 서버들을 관리할 수 있는 환경(전력, 공간, 냉각시설 등)을 갖추고있어 많은 서버들을 운영할 수 있는 최적의 환경이라고 할 수 있습니다. 데이터센터의 수많은 랙(Rack)은 하드웨어를 고정시킬 수 있는 선반이 있고, 서버, 네트워크 장비, 스토리지들을 선반에 고정시킬 수 있습니다. 뿐만아니라, 랙에는 전원을 공급하는 전원 콘센트가 이중화 돼있어, 하나의 전원 공급 장치(UPS)에 고장이 생겨도 서비스에 영향이 가지않도록 설계합니다.

![rack](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/rack.png)

단순히 랙에 빈 공간이 있다고해서 서버를 아무렇게나 꽂을 수는 없습니다. 서버가 들어갈 수 있는 충분한 공간(유닛)이 있는지, 랙에서 공급할 수 있는 전력은 충분한지, 연결되어야하는 네트워크 장비(스위치)와 케이블로 연결할 수 있는 거리인지. 충분히 다양한 점을 고려해야합니다.

<details>
<summary>검색해볼만한 키워드</summary>
<div markdown="1">
* UPS
* 이중화
</div>
</details>

<br>
<br>

그럼 이제 데이터 센터안에 있는 서버를 뜯어봅시다.

![real-server](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/real-server.png)

![simple-serveer](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/simple-server.png)

서버는 위의 그림처럼 여러 컴포넌트들이 버스로 연결되어있는 구조입니다. 기본적으로 집에서 사용하는 PC와 물리적인 기본 구성은 비슷하지만, **“하나의 컴포넌트가 고장나도 문제없도록 이중화 돼있다는 점”**과 “**컴포넌트들이 PC에 비해서 훨씬 고스펙”**이라는 측면에서 조금의 차이가 있을 뿐입니다. 서버는 일반적으로 위와 같은 하드웨어 구조를 가지고, 입출력장치(키보드, 모니터, 마우스 등) 또는 프로세스가 OS를 통해 명령을 내리면 CPU가 중앙에서 명령어를 처리하여 다른 컴포넌트를 동작시키며 다양한 업무(프린터 출력, 모니터 출력, 애플리케이션 실행 등)를 수행하게 됩니다.

![server-operation-process](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/server-operation-process.png)

<details>
<summary>검색해볼만한 키워드</summary>
<div markdown="1">
* 메모리 채널 (#메모리)
* NUMA (#CPU)
* UPI (#CPU)
* 이중화
* NIC (#네트워크)
* PCI, PCI Express 3.0 (#외부장치)
* SATA, SAS, NVMe (#저장장치)
* BMC = ILO, IDRAC, IPMI (#서버)
* 칩셋(PCH) (#서버)
* 프로세스와 프로그램의 차이
</div>
</details>

이제 서버 내부의 각각의 컴포넌트에 대해서 자세히 알아보겠습니다.

### 2-1. CPU

CPU(Central Processing Unit, 중앙 처리 장치)는 1초에 1억번 이상의 연산을 수행할 수 있는 고성능의 연산 장치입니다. 사람으로 치면 뇌라고 할 수 있겠습니다. **CPU는 기억장치에 저장돼있는 명령어와 데이터를 활용해서 연산을 수행하고, 기억장치로 결과를 반환하는 식으로 동작**합니다. CPU가 기억 장치에 있는 명령어와 데이터를 자체적으로 가져올 수 있는 것은 아니고, **“프로세스 & 입출력장치 명령 ⇒ OS(운영체제) ⇒ 기억장치(명령 + 데이터) ⇒ CPU(연산)"** 순으로 명령어와 데이터가 전달되며 CPU가 연산을 수행하게 됩니다.

이러한 연산을 수행하는 최소 단위를 코어(core)라고 하며, 최근에는 하나의 CPU에 여러 개의 코어(= 멀티코어 아키텍처)가 존재합니다. 각각의 코어는 각각 독립된 작업을 수행할 수 있고, 현대의 서버는 주로 멀티코어 + 멀티프로세서로 구성됩니다.

- 멀티 코어 = 하나의 CPU가 여러 개의 코어로 구성
- 멀티 프로세서 = 하나의 서버가 여러 개의 프로세서(CPU)로 구성

자, 그럼 실제로 제가 업무를 하면서 입고되는 서버의 CPU를 예로 들어 보겠습니다. 인텔이라는 CPU 제조사의 “[제온 Silver 4314 프로세서](https://www.intel.co.kr/content/www/kr/ko/products/sku/215269/intel-xeon-silver-4314-processor-24m-cache-2-40-ghz/specifications.html)”입니다. 아래 사진과 같이 CPU의 사양(스펙)은 대표적으로 **코어 수, 클럭 수**로 설명됩니다. ( 하지만 이외에도 CPU 아키텍처, 캐시 크기, 하이퍼 스레딩 등 CPU의 연산 속도에 영향을 미치는 요소는 많습니다. )

![cpu-spec](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/cpu-spec.png)

- 코어 = 연산을 수행할 수 있는 최소 단위
- 주파수 = CPU가 1초에 몇 번의 작업(클럭사이클)을 수행하는지

<details>
<summary>검색해볼만한 키워드</summary>
<div markdown="1">
* 멀티코어와 멀티프로세서
* 하이퍼 스레딩(Hyper Threading)
* NUMA
</div>
</details>

### 2-2. 메모리

전기적인 처리로 데이터를 저장하여, 전원이 끊기면 데이터가 사라지는 휘발성 기억장치입니다. 데이터가 휘발되는 대신, 물리적으로 데이터를 저장하는 장치(HDD)에 비해서 데이터 접근 속도가 훨씬 빠릅니다.

기억장치들은 CPU에 비해서 상대적으로 느린 속도로 동작합니다. **기억장치의 느린 동작 속도가 걸림돌이 되지않도록, 자주 사용하는 데이터와 명령어를 최대한 CPU와 가깝고, 동작이 빠른 기억장치에 저장하여 CPU 연산 지연을 최소화합니다.** 실제로 데이터 접근속도가 빠른 L1 캐시, L2캐시, L3캐시, 메모리, 보조기억장치(HDD, SSD) 순으로 코어와 가까운 곳에 위치시키고, 이것을 메모리 계층 구조라고 합니다.

- 저장공간 크기 = 레지스터 < L1 캐시 < L2 캐시 < L3 캐시 < 메모리 < 비휘발성 기억장치
- 데이터 접근 속도 = 레지스터 > L1 캐시 > L2 캐시 > L3 캐시 > 메모리(µs) > 비휘발성 기억장치(ms)

![memory-hierarchy](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/memory-hierarchy.png)

위의 이미지 처럼 메모리는 CPU와 채널(Channel)이라는 데이터 경로로 직접 연결되어 있습니다. L1, L2, L3 캐시와 다르게 메모리에 접근하기 위해서는 메모리 컨트롤러를 통해서 접근해야하므로 상대적으로 더 많은 레이턴시가 발생합니다.

<details>
<summary>검색해볼만한 키워드</summary>
<div markdown="1">
* 레이턴시
* 기억장치와 메모리 계층구조(레지스터, 캐시메모리, 메모리, 보조기억장치)
* 메모리 계층구조별 데이터 접근속도
* 캐시의 공간 지역성(Cache Locality)과 시간 지역성(Temporal Locality)
* 메모리 인터리빙
</div>
</details>

### 2-3. 보조기억장치(HDD/SSD) + 스토리지

메모리 계층구조에 따라서 보조기억장치는 메모리보다 CPU에서 더 먼곳에 배치되는 기억장치입니다. 보조기억장치는 메모리에 비해 데이터 접근속도가 느린 대신, 대용량으로 데이터를 저장할 수 있고, 전원이 끊겨도 데이터가 휘발되지않습니다.

실제로 물리서버에서는 전원이 끊겨도 보존해야하는 데이터(운영체제, 실행프로그램 등) 저장 목적으로 여러 보조기억장치를 Raid Controller에 장착하여 데이터 안정성을 확보합니다. 보조기억장치에서 저장하는 방식에는 크게 두 가지가 있고, HDD(Hard Disk Drive)는 디스크의 자성을 이용해서 데이터를 저장하고, SSD(Solid State Drive)는 전자적인 방법으로 데이터를 저장합니다.

<details>
<summary>검색해볼만한 키워드</summary>
<div markdown="1">
* Raid Controller
* RAID 0, 1, 1+0, 5, 6
* Disk Fault
* SAS, SATA, NVMe
* SSD, HDD 속도 비교
</div>
</details>

서버 자체적으로 갖고있는 보조기억장치의 용량과 성능에는 한계가 있으므로, 수많은 데이터를 저장해야할 때는 스토리지를 활용하기도 합니다. 스토리지란, 수많은 디스크를 장착하여 여러 서버에서 공용으로 대용량 데이터를 저장하려는 목적으로 사용하는 하드웨어입니다.

거대한 저장용량 뿐만아니라, 자체적으로 CPU와 캐시 메모리를 갖고있어서 빠른 속도로 데이터를 쓰거나 읽을 수 있습니다. 서버는 스토리지의 디스크와 직접 데이터를 교환하지않고, 캐시를 통해서 데이터를 교환하여 빠르게 읽기/쓰기가 가능합니다.

![storage-cash](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/storage-cash.png)

일반적으로 사용하는 스토리지의 종류는 크게 3가지(Block, File, Object)가 있고, 각각 저장 방식에 차이가 있으며 스토리지가 서버와 연결하는데 필요한 하드웨어 구성도 다릅니다. SAN 스토리지를 연결하기 위해서는 SAN 스위치, HBA 카드, FC 케이블이 필요한 반면에, NAS 스토리지는 NIC카드와 이더넷 케이블만 있으면 손쉽게 구성하여 사용할 수 있습니다.

<details>
<summary>검색해볼만한 키워드</summary>
<div markdown="1">
* SAN과 NAS의 차이(저장방식과, 물리구성, 성능 측면에서)
* HBA, FC 케이블
* NIC, 이더넷 포트
* 오브젝트 스토리지
</div>
</details>

### 2-4. 네트워크 인터페이스

서버를 다른 장치와 연결할 수 있는 인터페이스를 말합니다. 가정에서 사용하는 PC나, 노트북에서 랜선을 연결하기위한 포트를 생각하면 됩니다. 해당 인터페이스(포트)에 케이블을 꽂고, 다른 하드웨어(서버, 스위치, 스토리지 등 )와 연결하여 데이터를 주고받을 수 있게 됩니다. 보통 서버에 LAN 어댑터(NIC)이 장착되지만, 스토리지 연결목적으로 FC 어댑터(HBA)를 추가하여 장착할 수도 있습니다. 네트워크는 이후에 별도의 포스팅으로 자세하게 설명하겠습니다.

### 2-5. 서버내의 데이터 전송 경로

서버 내 데이터 전송 회선은 연결 대상과 목적에 따라 다양합니다.

- CPU ↔ CPU 데이터 전송 목적 = UPI(Ultra Path Interconnect)
- CPU ↔ 메모리 데이터 전송 목적 = 채널(Channel)
- CPU ↔ 입출력장치 데이터 전송 목적 = PCI 회선
- CPU ↔ 처리 속도가 늦어도 되는 저속 입출력(네트워크, USB, …) 목적 = PCH 칩셋(I/O컨트롤러) + DMI

![server-bus](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/server-bus.png)

<details>
<summary>검색해볼만한 키워드</summary>
<div markdown="1">
* BMC
* DMI + PCH
</div>
</details>

### 2-6. 버스

버스는 서버 내 컴포넌트들을 연결시키는 회선을 말합니다. 컴포넌트간 데이터의 전송속도는 버스의 대역폭(한번에 얼마나 보낼 수 있는지)과 전송속도(1초에 몇 번 전송하는지)에 의해 결정됩니다.

예를 들어, 버스 인터페이스 규격 중 하나인 PCI Express 3.0은 버스 1회선 당 2GB/s 전송이 가능합니다.

메모리 계층구조와 같은 원리로, CPU에 가까울수록 버스의 대역폭이 높고, 멀수록 버스의 대역폭이 낮은게 일반적입니다. 외부 연결장치와 연결을 검토할 때 외부 연결장치의 데이터 전송속도가 버스의 전송속도보다 높아 버스에서 병목현상이 발생하지않도록 하는 것이 중요합니다.

### 2-7. 요약

여기까지 IT 인프라 아키텍처를 구성하는 서버, 그리고 서버 내부의 컴포넌트들을 살펴보았습니다.

CPU에 대해서 소개할때, 프로세스/입출력장치의 명령에 따라서 OS가 기억장치에서 명령어와 데이터를 CPU에 전달하고, 컴퓨터가 동작한다고 했습니다. 아래의 이미지는 SAN 스토리지에서 CPU로의 데이터 흐름입니다. 아래 이미지를 지금까지 살펴본 내용과 엮어서 이해해봅시다.

- 메모리 계층 구조
- 버스
- 네트워크 인터페이스

![server-summary](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/server-summary.png)

<br>
<br>
<br>

## 3. 3계층형 시스템

IT 인프라 아키텍처에는 어떤 것이 있고, 그 아키텍처를 이루는 서버는 어떻게 구성돼있는지 살펴보았습니다. 이제 여러 서버들을 이용해서 물리적인 시스템를을 구성했을 때, 실제로 어떻게 IT 서비스를 제공하고 있는지 일반적으로 사용되는 아키텍처인, 수직분산형 아키텍처(3계층 아키텍처)안에서 데이터 흐름을 보며 그 원리를 자세히 알아보겠습니다.

### 3-1. 3계층형 시스템

앞에서 소개했던 “수직 분할형 아키텍처”는 현재 많은 IT 서비스에서 일반적으로 채택되는 아키텍처입니다. 3계층형(3-Tier) 아키텍처라고도 하는데, 서버의 역할을 크게 WEB, WAS(AP), DB의 3계층으로 구분합니다. 이러한 구성은 계층 중간중간에 성능 향상을 위해서 캐시 서버를 도입하는 등 시스템 특징에 따라 달라질 수 있습니다.

아래의 그림은 3계층 구조가 어떻게 구성돼있는지 정말 간단하게 보여주고 있습니다.

![3-layer-arch](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/3-layer-arch.png)

각 서버의 역할(WEB, WAS, DB)에 따라 운영체제 위에서 각자의 역할에 특화된 프로세스가 돌아가며 서버의 자원(CPU, 메모리, 입출력장치)을 활용하고, 각 서버들은 네트워크를 통해 연결되어 요청과 응답을 주고받으며 사용자들에게 IT 서비스를 제공하게 됩니다.

이제부터 물리적인 구성 위에서 동작하고 있는 “**프로세스”, “스레드”, “커널”**이라는 논리 구성에 대해서 알아봅시다.

<br>
<br>

### 3-2. 프로세스와 스레드

우리는 평소에 PC를 켜고 바탕화면에 설치돼있는 파워포인트, LOL 등 다양한 프로그램을 클릭하여 실행하고, 쉽고 간편하게 사용합니다. 사실 이러한 프로그램들은 서버가 전원이 꺼져도 데이터가 보존되어야하므로, 평소에는 보조기억장치(HDD, SSD)에서 **“프로그램”**으로 죽어있다가, 클릭하여 실행하는 순간 프로그램이 메모리에 올라가면서 **“프로세스”**로 살아나게 됩니다. 살아난 프로세스는 CPU를 점유하면서, 프로그램에 적혀있던 명령어와 데이터를 처리하며 동작하게 됩니다.
이러한 일련의 과정을 OS(운영체제)가 총괄하게 되는데, 특히 **커널**이 핵심 역할을 담당하게 됩니다.

![program-to-process](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/program-to-process.png)

프로세스는 CPU에서 동작하기 위해서 깨어난 프로그램이라고 했습니다. 프로세스는 **“스레드(작업의 최소단위)”**로 한번 더 나눌 수 있습니다. 하나의 프로세스는 여러 스레드로 나누지 않았을 때, 하나의 스레드가 동작하고 있다고 볼 수 있습니다.

**프로세스**는 프로세스마다 독립된 메모리 공간을 가지고 있어 서로의 메모리 공간에 접근하지 못하는 반면에, **스레드**는 하나의 프로세스 내에서 여러 스레드가 메모리 공간을 공유합니다. 따라서 서로 독립적인 프로세스는 장애가 전파되지 않지만, 하나의 스레드에 문제가 생기면 다른 스레드들이 영향을 받게 됩니다. 하지만 **스레드**는 스레드마다 별도의 메모리 공간을 갖고있지 않으므로 프로세스에 비해 가볍다는 특징이 있습니다. 이외에도 다양한 차이점이 있습니다.

- 독립성 : 프로세스 > 스레드
- 컨텍스트 스위칭 시 부하 : 프로세스 > 스레드
- 신규 생성시 부하 : 프로세스 > 스레드
- 프로그래밍 복잡성 : 프로세스 < 스레드

![process-thread](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/process-thread.png)

프로그램을 작성할 때 프로세스를 사용할지, 스레드를 사용할지는 각각의 특성과 장단점을 충분히 이해한 후 결정해야합니다.

<details>
<summary>검색해볼만한 키워드</summary>
<div markdown="1">
* 컨텍스트 스위칭
* 오라클의 PGA, SGA
* 공유 자원과 Mutual Exclustion
</div>
</details>

<br>
<br>

### 3-3. OS 커널

**“커널”**이란 OS의 핵심 기능을 담당하는 부분입니다. 커널은 복잡한 OS/하드웨어의 작동 방법을 숨기고, 간단한 인터페이스를 제공합니다. 개발자들은 하드웨어와 OS의 동작을 하나하나 이해하고, 동작시키기 위한 노력을 할 필요없이, 커널 덕분에 간단하게 프로그램을 작성해도 하드웨어와 운영체제를 동작시킬 수 있게 됩니다.

운영체제의 심장, 커널의 핵심 역할은 총 6가지로 분류할 수 있습니다.

1. 시스템 콜 인터페이스
2. 프로세스 관리(프로세스 스케쥴링)
3. 메모리 관리
4. 네트워크 스택
5. 파일 시스템 관리
6. 장치 드라이버

각각의 역할에 대해서 자세히 알아보겠습니다.

**1. 시스템 콜 인터페이스 = 프로세스/스레드에서 커널로 연결되는 통로**

- 애플리케이션(프로세스/스레드)이 OS를 통해서 어떤 처리(네트워크 통신, 파일 데이터 읽기 등)를 해야할 때, 시스템 콜이라는 통로를 통해서 커널으로 명령을 전달한다.
- 이러한 명령은 시스템 콜 인터페이스를 통해서 전달되고, 수행된다. 커널내에서 이러한 명령이 어떤 과정을 통해서 실행되는지 자세히 몰라도 된다.
- 우리가 프로그래밍 언어에서 파일을 읽고, 쓰는 일련의 과정은 시스템 콜을 통해서 간단하게 처리된다는 뜻이다.

<br>

**2. 프로세스 관리(프로세스 스케쥴링)**

- OS 상에서 프로세스를 생성, 실행, 관리한다.
- 여러 프로세스가 어느 순서로 실행될 지, 어떤 CPU의 코어를 사용할지 등을 관리한다.

<br>

**3. 메모리 관리**

- 프로세스에서 사용할 메모리 공간 확보하고 할당해준다.
- 서로 다른 프로세스의 메모리 공간을 침범하지 못하도록 메모리를 관리해준다.

<br>

**4. 네트워크 스택**

- `다른 서버와 통신할 때 필요한 소켓(소켓 버퍼, 수신/송신 버퍼)을 생성하고 관리해준다.`
- `애플리케이션에서 전송하고자하는 데이터를 세그먼트(패킷)로 분리해준다.`

<br>

**5. 파일시스템 관리**

- 물리 디스크에 있는 이진 데이터를 사용하기 쉽게 파일 단위로 이용할 수 있도록 인터페이스를 제공해주어, 물리 디스크의 작동 방식에 대해서 알 필요가 없다.
- 프로세스에서도 파일 단위로 데이터를 관리할 수 있게 된다.
- 디렉토리 구조를 제공하고, 액세스 관리 등이 가능해진다.

<br>

**6. 장치 드라이버**

- 각 제조사에서 운영체제에 적합한 장치 드라이버를 제공하면, 장치 내부 작동 과정을 자세하게 알 필요 없이 시스템 콜을 통해서 제조사와 관계없이 하드웨어 장치를 쉽게 제어할 수 있게 된다.

<br>
<br>

### 3-4. 3계층 구조의 시스템의 흐름

3계층 시스템에 대해서 자세히 알아보기에 앞서, 논리적인 구성의 기본이 되는 운영체제(OS)와 커널, 프로세스, 스레드에 대해서 알아보았습니다.

먼저, 3계층 구조에 대해 간단하게 요약해보겠습니다.

1. 3계층 시스템에서 각 서버는 역할에 맞게 애플리케이션(프로세스/스레드)를 실행한다.
2. 각 애플리케이션에서 수행되는 데이터읽기/쓰기, 네트워크 통신 등 하드웨어(CPU, 메모리, NIC, … )와 운영체제를 사용해야하는 복잡한 동작들은 모두 커널에 의해서 관리된다.
3. 각 서버는 각자의 역할을 수행한 후, 서로 요청과 응답을 주고받으며, 최종적으로 사용자에게 IT 서비스를 제공한다.

그러면 이제부터 **“각 서버가 서로 어떻게 데이터를 주고받고, 어떻게 IT 서비스를 제공하는지”** 알아보겠습니다. (웹 서버, AP 서버, DB 서버에서 동작하는 순서를 볼 때, 어디서 시스템 콜이 동작하고, 커널이 작동할지 생각하면서 알아보면 더 좋을 것 같습니다.)

![3-layer-data-flow](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/3-layer-data-flow.png)

구글 크롬을 통해서 유튜브에 접속하는 경우를 예를 들어 설명해보겠습니다.

<br>

**흐름 1) 클라이언트(PC) → 웹서버**

1. 클라이언트가 웹 브라우저 프로그램(구글 크롬)을 실행시켜 프로세스를 생성한다.
2. 웹 브라우저(구글 크롬)의 주소창에 특정 사이트(www.youtube.com)를 입력하여 HTTP 요청을 보낸다.
3. 다른 서버로 요청을 보내기위해서는 서버의 IP 주소(223.xxx.xxx.xxx)를 알아야하므로, DNS 서버에 요청을 보내서 이름(www.youtube.com)을 IP 주소로 해석한다.
4. 클라이언트는 해석한 IP 주소를 이용해서 웹 서버(youtube)에 성공적으로 접속하게 된다.
5. 웹 서버 역할의 “httpd 프로세스”는 클라이언트가 요청한 콘텐츠의 종류(정적 콘텐츠, 동적 콘텐츠)에 맞게 데이터를 처리하여 반환할 준비를 한다.
   1. 정적콘텐츠 = 낮은 빈도로 변경되는 데이터(로고 이미지, … ) = 웹서버에서 저장된 데이터를 이용해서 자체적으로 처리
   2. 동적콘텐츠 = 높은 빈도로 변경되는 데이터(조회수 정보, 댓글 정보, … ) = AP서버에서 실시간으로 만들어 줘야하므로 AP서버로 요청을 보내고 동적 컨텐츠를 기다린다.

![client-to-web](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/client-to-web.png)

<details>
<summary>검색해볼만한 키워드</summary>
<div markdown="1">
* DNS 이름 해석(DNS Name Resolution)
* httpd 프로세스 & 아파치(Apache)
</div>
</details>

<br>
<br>

**흐름 2) 웹서버 → AP 서버(WAS 서버)**

위에서 정적인 콘텐츠는 웹서버 자체적으로 처리할 수 있지만, 동적인 콘텐츠는 AP서버가 생성하여 전달해주어야 합니다. AP 서버의 동작을 살펴봅시다.

1. 웹 서버로부터 동적 콘텐츠를 만들어달라는 요청이 도착한다. ( 인터럽트 발생 )
2. AP서버 프로세스 내의 스레드가 요청을 받고 자신이 직접 처리해서 반환할 수 있는지, DB서버(youtube DB서버)의 데이터가 필요한지 판단한다.
3. DB서버의 데이터가 필요하지 않으면, 직접 처리하여 동적인 콘텐츠를 생성하고, 웹서버로 응답을 보낸다. 규모가 작고, 빈번하게 사용해야하는 데이터는 AP 서버 내부에서 데이터를 캐싱하거나, 캐시서버를 DB서버 앞에 두어 요청을 더 빠르게 처리할 수 있다.
4. DB서버의 데이터가 필요하면, DB서버로 요청을 보낸다.
5. DB서버의 데이터를 응답으로 받고, 데이터를 처리해서 동적인 콘텐츠를 생성하고, 웹서버로 응답을 보낸다.

![web-to-ap](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/web-to-ap.png)

<details>
<summary>검색해볼만한 키워드</summary>
<div markdown="1">
* CDN
* 톰캣(Tomcat)
* WAS
* 인터럽트(Interrupt)
* 연결 풀(Connection Pool)
</div>
</details>

<br>
<br>

**흐름 3) AP서버 → DB서버 → AP서버**

AP서버는 DB서버에 SQL쿼리문으로 필요한 데이터를 요청하게 되고, DB서버는 SQL쿼리문을 해석(파싱하여 DB서버의 디스크 또는 메모리에서 필요한 데이터를 꺼내온다.

1. AP서버로부터 요청이 도착한다.
2. DB프로세스가 요청을 받고, 이전에 사용하여 메모리에 캐싱된 정보가 있는지 확인한다.
3. 캐시된 정보가 없으면, 디스크에서 데이터를 읽어온다.
4. 한번 액세스한 데이터는 메모리에 캐시 형태로 저장하고, 이후 액세스할때 재사용한다.
5. 요청을 보낸 AP서버로 SQL 요청에 대한 응답(데이터)을 반환한다.

![ap-db-ap](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/ap-db-ap.png)

DB서버의 구체적인 동작은 데이터베이스 종류에 따라 다르고, RDBMS 인지, NoSQL인지, In-memory DB인지에 따라 또 동작방식이 다르니, 참고차 찾아보시면 좋을 것 같습니다.

<details>
<summary>검색해볼만한 키워드</summary>
<div markdown="1">
* RDBMS, NoSQL, 인메모리 DB
</div>
</details>

<br>
<br>

**흐름 4) AP서버 → 웹서버**

AP서버는 동적 컨텐츠 생성에 필요한 데이터를 DB서버로부터 전달받고, 동적 컨텐츠를 생성하게 됩니다. 생성된 동적 컨텐츠는 웹서버로 반환됩니다.

1. DB서버에 요청했던 데이터가 응답으로 반환된다.
2. AP서버의 스레드가 데이터를 가지고 동적 콘텐츠를 생성한다.
3. 동적 콘텐츠를 웹서버에게 반환한다.

![ap-to-web](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/ap-to-web.png)

<br>
<br>

**흐름 5) 웹서버 → 클라이언트(PC)**

웹서버는 AP서버로 부터 전달받은 동적 컨텐츠를 클라이언트에게 반환합니다.

1. AP서버가 동적 콘텐츠를 반환한다.
2. 웹서버 프로세스는 동적콘텐츠를 클라이언트(웹 브라우저)에게 반환한다.
3. 콘텐츠(정적+동적)가 웹 브라우저(구글 크롬)에 표시된다.

![web-to-client](https://honghyeong-github-page.s3.ap-northeast-2.amazonaws.com/easy-it-infra/1/web-to-client.png)

정리하자면, 3계층 시스템은 다음과 같이 동작합니다.

- 프로세스/스레드는 요청을 받는다.
- 요청을 직접 처리할 수 있는 것은 바로 반환하고, 필요하다면 별도 서버로 요청을 보낸다.
- 요청에 대해서 응답을 반환한다.

## 4. 총 정리

여기까지 IT 인프라에 대해서 알아보았습니다. 처음 말씀드렸던 것처럼, IT 인프라는 IT 서비스 이용자들이 내부 작동방식을 이해하지 못해도 손쉽게 사용할 수 있는 IT 기반이라고 했습니다. 위의 3계층 데이터 흐름처럼, 서비스 사용자들은 단순하게 “요청”하면 “응답”을 받을 뿐입니다.

지금까지의 살펴본 내용을 바탕으로 IT 간편한 서비스 안에서 어떤 과정이 있는지 정리해보겠습니다.

1. 인프라 엔지니어들은 안정적인 아키텍처를 설계하여, IT 서비스를 안정적으로 제공하고 있습니다.
2. 아키텍처를 이루는 수많은 서버는 CPU, 메모리, 보조기억장치, 네트워크 인터페이스, 버스 등으로 구성돼있습니다.
3. 개발자들은 IT 서비스를 제공하기 위해서 프로그램(애플리케이션)을 작성하고, 이러한 프로그램들은 프로세스/스레드로 동작하며 커널의 도움을 받아 서버의 하드웨어와 상호작용하거나, 네트워크를 통해서 다른 서버와 상호작용합니다.
4. 사용자들이 IT 서비스를 간편하고, 안정적으로 사용할 수 있게 됩니다.

다음에는 3계층 데이터 흐름안에서 어떤 CS지식과 기술이 적용됐는지, 서버는 네트워크로 어떻게 통신하는지, 안정적인 서비스 운영을 위해서 인프라 엔지니어는 어떤 일을 하는지, 빠르게 서비스를 제공하기 위해서 어떤 일을 하는지 알아보겠습니다.

지금까지 긴 글을 읽어주셔서 감사합니다.

<br>
<br>

## 5. Reference

- **Book**
  - 그림으로 공부하는 IT 인프라 구조

<br>

- **Image**
  - Intel
  - 그림으로 공부하는 IT 인프라 구조
